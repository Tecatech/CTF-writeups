# ezdlp

As the form of `q` is vulnerable to Pollard's rho, we can easily recover `q` and `p`.

```py
from output import messages, enc
from tqdm import tqdm
import random
from gmpy2 import *
from multiprocessing import Pool

a = 2 ** 2
n = mpz(131158523227880830085100826212925738665356578827561846263073537503153187073136528966506785633847097997799377037969243883439723340886038624250936927221630287086602285835045356221763554989140952262353930420392663280482277832613695689454662506372252641564106136178637816827646124189347219273164844809807934422046441)

for p in tqdm(range(2 ** 24 + 1, 2 ** 25, 2)):
    if not is_prime(p):
        continue
    a = pow(a, mpz(p), n)

def func(x):
    if not is_prime(x):
        return
    wow = pow(a, x, n)
    res = gcd(wow - 1, n)
    if res != 1 and res != n:
        print(res)
        return res
    return

with Pool() as p:
    r = tqdm(p.imap(func, p.map(func, range(2 ** 31 + 1, 2 ** 32, 2))), total=2 ** 30)
    print("Done")
    print(list(r))
```

Also, we can use `q` value to recover the flag.

```py
from output import messages, enc
from Crypto.Util.number import *

flag_enc = enc[-1]
n = 131158523227880830085100826212925738665356578827561846263073537503153187073136528966506785633847097997799377037969243883439723340886038624250936927221630287086602285835045356221763554989140952262353930420392663280482277832613695689454662506372252641564106136178637816827646124189347219273164844809807934422046441
q = 12980311456459934558628309999285260982188754011593109633858685687007370476504059552729490523256867881534711749584157463076269599380216374688443704196597025947
res = GF(q)(flag_enc).log(GF(q)(0x10001))

print(res)
print(long_to_bytes(res2))
```

The flag is `n1ctf{1f1b18f9-8523-4584-a8eb-c8b5c9c9433d}`.